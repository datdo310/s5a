#######
# v0r01: -          1st from E1M-S
# v0r02: 2016/06/11 From Minoda-san to improve TAT
# v0r03: 2017/03/08 Change Overwrite for PTECO
# v0r04: 2017/06/20 Change NBTI formula "-" -> "+"
#######
############################################################
# Set MaxTransition for low drive cell main script
#     Generated by make_DRV_script V03.01.00
############################################################
############################################################
# set constraint factors
############################################################
# time scale factor
set Tunit [get_attribute [current_design] time_unit_in_second]
set Tfactor [expr 1.0e-9/$Tunit]
# capacitance scale factor
set Cunit [get_attribute [current_design] capacitance_unit_in_farad]
set Cfactor [expr 1.0e-12/$Cunit]

############################################################
# source utility procedures
############################################################
#if { ![info exists DLCLT_UTIL_PATH] } {
#    set DLCLT_UTIL_PATH "/common/appl/Renesas/OPENCAD/R2016.03/tools/DELAYCALC_LITE/utility"
#}
#source ${DLCLT_UTIL_PATH}/get_min_period.tcl
#source ${DLCLT_UTIL_PATH}/get_half_cycle_path_v2.tcl
#
#############################################################
## source constraint setting procedures
#############################################################
## lowdrv constraint setting procedure
#if { ![info exists DLCLT_MAXTRAN_LOWDRV_PROC_TCL] } {
#    source /eda04/daltmu08/rv40f_phase1_drv_env_for_yoshida-san/run.config.file/drv_scr/dlclt_maxtran_lowdrv_proc.scr
#} else {
#    source $DLCLT_MAXTRAN_LOWDRV_PROC_TCL
#}

############################################################
# define global variables
############################################################
global DLCLT_HalfCyclePath
# Period limit for half cycle check
if { [info exists DLCLT_HALF_CYCLE_MAXTRAN_PERIOD_LIMIT] } {
    set DLCLT_HALF_CYCLE_MAXTRAN_PERIOD_LIMIT [expr $DLCLT_HALF_CYCLE_MAXTRAN_PERIOD_LIMIT * $Tfactor]
} else {
    set DLCLT_HALF_CYCLE_MAXTRAN_PERIOD_LIMIT 1.0e9
}

### suppress PTE-079 warning
suppress_message PTE-079

#############################################################
## Main routine
#############################################################
if {[info exist PTECO_FIX_DRC]} {
    puts "* Information : Skip Reset maxtran constraints"
    set overwrite 0
} else {
    puts "* Information : Reset maxtran constraints"
    set_max_transition 9999.999 [get_pins * -hier]
    set_max_transition 9999.999 -data_path [all_clocks]
    set_max_transition 9999.999 -clock_path [all_clocks]
    set overwrite 1
}



### suppress PTE-079 warning
suppress_message PTE-079

### set maxtran lowdrv flag
global DLCLT_SET_MAXTRAN_LOWDRV_FLAG
set DLCLT_SET_MAXTRAN_LOWDRV_FLAG 0

### main routine for normal cycle path
# define overwrite flag 1(true)
# set overwrite 1			;# Comment out for PTECO
set MAXTRAN_LOWDRV_Vall_TMIN0 [expr 2.050e-09/$Tunit/(1+$MAXTRANCAP_FREQ_RELAX)]		;# over 480MHz
set MAXTRAN_LOWDRV_Vall_TMAX0 [expr 3.050e-09/$Tunit/(1+$MAXTRANCAP_FREQ_RELAX)]		;# over 320MHz
set MAXTRAN_LOWDRV_Vall_TMIN1 [expr 3.050e-09/$Tunit/(1+$MAXTRANCAP_FREQ_RELAX)]		;# over 320MHz
set MAXTRAN_LOWDRV_Vall_TMAX1 [expr 6.10e-09/$Tunit/(1+$MAXTRANCAP_FREQ_RELAX)]			;# over 160MHz
set MAXTRAN_LOWDRV_Vall_TMIN2 [expr 6.10e-09/$Tunit/(1+$MAXTRANCAP_FREQ_RELAX)]			;# over 160MHz

### main loop for TLH
foreach_in_collection inst [get_cells * -hier -quiet -filter "ref_name=~TLH*X*&&is_hierarchical==false"] {
    # get library cell name
    set lib_cell_name [get_attribute $inst ref_name]

    # get drive
    if { [regexp {^TLH\S*X(\d+)$} $lib_cell_name match drive] == 0 } { continue }
    # trim ^0
    regsub {^0+} $drive {} drive
    if { $drive == "" } { set drive 0 }

    # check drive limit
    if { [check_drive_limit_TLH $drive] == 0 } { continue }

    # get output pins
    set outpins [get_pins -quiet -leaf -of $inst -filter "direction=~*out&&is_hierarchical==false"]
    if { $outpins == "" } { continue }

    # set maxtran lowdrv cell's pin
    foreach_in_collection pin $outpins {
        # get minimum period
        set path_flag [get_attribute $pin dlclt_clk_path_flag]
        set period [get_min_period $pin "out" $path_flag]
        #if { $period >= $MAXTRAN_LOWDRV_Vall_TMIN0 && $period < $MAXTRAN_LOWDRV_Vall_TMAX0 }  ;# remove for analyzing over 480MHz
        if { $period < $MAXTRAN_LOWDRV_Vall_TMAX0 } {
            set_maxtran_lowdrv_Vall_F3p200000et08to4p800000et08_TLH $pin $drive $overwrite
        } elseif { $period >= $MAXTRAN_LOWDRV_Vall_TMIN1 && $period < $MAXTRAN_LOWDRV_Vall_TMAX1 } {
            set_maxtran_lowdrv_Vall_F1p600000et08to3p200000et08_TLH $pin $drive $overwrite
        }

    }
}

### main loop for THH
foreach_in_collection inst [get_cells * -hier -quiet -filter "ref_name=~THH*X*&&is_hierarchical==false"] {
    # get library cell name
    set lib_cell_name [get_attribute $inst ref_name]

    # get drive
    if { [regexp {^THH\S*X(\d+)$} $lib_cell_name match drive] == 0 } { continue }
    # trim ^0
    regsub {^0+} $drive {} drive
    if { $drive == "" } { set drive 0 }

    # check drive limit
    if { [check_drive_limit_THH $drive] == 0 } { continue }

    # get output pins
    set outpins [get_pins -quiet -leaf -of $inst -filter "direction=~*out&&is_hierarchical==false"]
    if { $outpins == "" } { continue }

    # set maxtran lowdrv cell's pin
    foreach_in_collection pin $outpins {
        # get minimum period
        set path_flag [get_attribute $pin dlclt_clk_path_flag]
        set period [get_min_period $pin "out" $path_flag]
        #if { $period >= $MAXTRAN_LOWDRV_Vall_TMIN0 && $period < $MAXTRAN_LOWDRV_Vall_TMAX0 } ;# remove for analyzing over 480MHz
        if { $period < $MAXTRAN_LOWDRV_Vall_TMAX0 } {
            set_maxtran_lowdrv_Vall_F3p200000et08to4p800000et08_THH $pin $drive $overwrite
        } elseif { $period >= $MAXTRAN_LOWDRV_Vall_TMIN1 && $period < $MAXTRAN_LOWDRV_Vall_TMAX1 } {
            set_maxtran_lowdrv_Vall_F1p600000et08to3p200000et08_THH $pin $drive $overwrite
        } elseif { $period >= $MAXTRAN_LOWDRV_Vall_TMIN2 } {
            set_maxtran_lowdrv_Vall_Fto1p600000et08_THH $pin $drive $overwrite
        }

    }
}

### main loop for TMH
foreach_in_collection inst [get_cells * -hier -quiet -filter "ref_name=~TMH*X*&&is_hierarchical==false"] {
    # get library cell name
    set lib_cell_name [get_attribute $inst ref_name]

    # get drive
    if { [regexp {^TMH\S*X(\d+)$} $lib_cell_name match drive] == 0 } { continue }
    # trim ^0
    regsub {^0+} $drive {} drive
    if { $drive == "" } { set drive 0 }

    # check drive limit
    if { [check_drive_limit_TMH $drive] == 0 } { continue }

    # get output pins
    set outpins [get_pins -quiet -leaf -of $inst -filter "direction=~*out&&is_hierarchical==false"]
    if { $outpins == "" } { continue }

    # set maxtran lowdrv cell's pin
    foreach_in_collection pin $outpins {
        # get minimum period
        set path_flag [get_attribute $pin dlclt_clk_path_flag]
        set period [get_min_period $pin "out" $path_flag]
        #if { $period >= $MAXTRAN_LOWDRV_Vall_TMIN0 && $period < $MAXTRAN_LOWDRV_Vall_TMAX0 } ;# remove for analyzing over 480MHz
        if { $period < $MAXTRAN_LOWDRV_Vall_TMAX0 } {
            set_maxtran_lowdrv_Vall_F3p200000et08to4p800000et08_TMH $pin $drive $overwrite
        } elseif { $period >= $MAXTRAN_LOWDRV_Vall_TMIN1 && $period < $MAXTRAN_LOWDRV_Vall_TMAX1 } {
            set_maxtran_lowdrv_Vall_F1p600000et08to3p200000et08_TMH $pin $drive $overwrite
        } elseif { $period >= $MAXTRAN_LOWDRV_Vall_TMIN2 } {
            set_maxtran_lowdrv_Vall_Fto1p600000et08_TMH $pin $drive $overwrite
        }

    }
}

### main loop for half cycle paths
# set overwrite flag 0(false)
set overwrite 0
if { [info exists DLCLT_ENABLE_HALF_CYCLE_MAXTRAN_LOWDRV] && [string equal -nocase $DLCLT_ENABLE_HALF_CYCLE_MAXTRAN_LOWDRV "yes"] } {
    if { $DLCLT_HALF_CYCLE_MAXTRAN_PIN_LIST != "" } {
        # get half cycle path
        if { ![info exists DLCLT_HalfCyclePath] } {
            set DLCLT_HalfCyclePath [get_half_cycle_path_start_end_pair $DLCLT_HALF_CYCLE_MAXTRAN_PIN_LIST \
                $DLCLT_HALF_CYCLE_MAXTRAN_NWORST $DLCLT_HALF_CYCLE_MAXTRAN_MAX_PATHS]
        }
        set filter ""
        foreach_in_collection tp $DLCLT_HalfCyclePath {
            # set half cycle period
            if { [string equal -nocase $DLCLT_HALF_CYCLE_CLOCK_POINT "start"] } {
                set clkname [get_object_name [get_attribute $tp startpoint_clock]]
            } elseif { [string equal -nocase $DLCLT_HALF_CYCLE_CLOCK_POINT "end"] } {
                set clkname [get_object_name [get_attribute $tp endpoint_clock]]
            } else {
                set clkname [get_object_name [get_attribute $tp startpoint_clock]]
                append clkname " [get_object_name [get_attribute $tp endpoint_clock]]"
            }
            get_min_clock_and_period_from_namelist $clkname min_clock period
            set period [expr $period * 0.5]
            # set maxtran lowdrv for half cycle path
            set tp_pins [filter_half_cycle_pin $tp $filter]
            foreach_in_collection pin [filter_collection $tp_pins "direction=~*out&&is_clock_pin==false&&is_hierarchical==false"] {
                set lib_cell_name [get_attribute [get_cells -quiet -of $pin] ref_name]
                # TLH
                if { [regexp {^TLH\S*X(\d+)$} $lib_cell_name match drive] != 0 } {
                    # trim ^0
                    regsub {^0+} $drive {} drive
                    if { $drive == "" } { set drive 0 }
                        #if { $period >= $MAXTRAN_LOWDRV_Vall_TMIN0 && $period < $MAXTRAN_LOWDRV_Vall_TMAX0 } ;# remove for analyzing over 480MHz
                        if { $period < $MAXTRAN_LOWDRV_Vall_TMAX0 } {
                            set_maxtran_lowdrv_Vall_F3p200000et08to4p800000et08_TLH $pin $drive $overwrite
                        } elseif { $period >= $MAXTRAN_LOWDRV_Vall_TMIN1 && $period < $MAXTRAN_LOWDRV_Vall_TMAX1 } {
                            set_maxtran_lowdrv_Vall_F1p600000et08to3p200000et08_TLH $pin $drive $overwrite
                        }

                # THH
                } elseif { [regexp {^THH\S*X(\d+)$} $lib_cell_name match drive] != 0 } {
                    # trim ^0
                    regsub {^0+} $drive {} drive
                    if { $drive == "" } { set drive 0 }
                        #if { $period >= $MAXTRAN_LOWDRV_Vall_TMIN0 && $period < $MAXTRAN_LOWDRV_Vall_TMAX0 } ;# remove for analyzing over 480MHz
                        if { $period < $MAXTRAN_LOWDRV_Vall_TMAX0 } {
                            set_maxtran_lowdrv_Vall_F3p200000et08to4p800000et08_THH $pin $drive $overwrite
                        } elseif { $period >= $MAXTRAN_LOWDRV_Vall_TMIN1 && $period < $MAXTRAN_LOWDRV_Vall_TMAX1 } {
                            set_maxtran_lowdrv_Vall_F1p600000et08to3p200000et08_THH $pin $drive $overwrite
                        } elseif { $period >= $MAXTRAN_LOWDRV_Vall_TMIN2 } {
                            set_maxtran_lowdrv_Vall_Fto1p600000et08_THH $pin $drive $overwrite
                        }

                # TMH
                } elseif { [regexp {^TMH\S*X(\d+)$} $lib_cell_name match drive] != 0 } {
                    # trim ^0
                    regsub {^0+} $drive {} drive
                    if { $drive == "" } { set drive 0 }
                        #if { $period >= $MAXTRAN_LOWDRV_Vall_TMIN0 && $period < $MAXTRAN_LOWDRV_Vall_TMAX0 } ;# remove for analyzing over 480MHz
                        if {  $period < $MAXTRAN_LOWDRV_Vall_TMAX0 } {
                            set_maxtran_lowdrv_Vall_F3p200000et08to4p800000et08_TMH $pin $drive $overwrite
                        } elseif { $period >= $MAXTRAN_LOWDRV_Vall_TMIN1 && $period < $MAXTRAN_LOWDRV_Vall_TMAX1 } {
                            set_maxtran_lowdrv_Vall_F1p600000et08to3p200000et08_TMH $pin $drive $overwrite
                        } elseif { $period >= $MAXTRAN_LOWDRV_Vall_TMIN2 } {
                            set_maxtran_lowdrv_Vall_Fto1p600000et08_TMH $pin $drive $overwrite
                        }

                }
            }
        }
    } else {
        # make cell filter
        make_half_cycle_check_filter $DLCLT_HALF_CYCLE_MAXTRAN_INCLUDE_LIST \
                $DLCLT_HALF_CYCLE_MAXTRAN_EXCLUDE_LIST filter
        # get half cycle path
        if { ![info exists DLCLT_HalfCyclePath] } {
            # clock loop
            foreach_in_collection clock [get_clocks *] {
                set clkname [get_object_name $clock]
                # get half cycle path
                get_half_cycle_path_for_clock $clock $filter \
                        $DLCLT_HALF_CYCLE_MAXTRAN_NWORST $DLCLT_HALF_CYCLE_MAXTRAN_MAX_PATHS
            }
        }
        # set lowdrv
        foreach keyname [array names DLCLT_HalfCyclePath] {
            foreach_in_collection tp $DLCLT_HalfCyclePath($keyname) {
                # set half cycle period
                if { [string equal -nocase $DLCLT_HALF_CYCLE_CLOCK_POINT "start"] } {
                    set pckname [get_object_name [get_attribute $tp startpoint_clock]]
                } elseif { [string equal -nocase $DLCLT_HALF_CYCLE_CLOCK_POINT "end"] } {
                    set pckname [get_object_name [get_attribute $tp endpoint_clock]]
                } else {
                    set pckname [get_object_name [get_attribute $tp startpoint_clock]]
                    lappend pckname [get_object_name [get_attribute $tp endpoint_clock]]
                }
                get_min_clock_and_period_from_namelist $pckname min_clock period
                set period [expr $period * 0.5]
                # set maxtran lowdrv for half cycle path
                set tp_pins [filter_half_cycle_pin $tp $filter]
                foreach_in_collection pin [filter_collection $tp_pins "direction=~*out&&is_clock_pin==false&&is_hierarchical==false"] {
                    set lib_cell_name [get_attribute [get_cells -quiet -of $pin] ref_name]
                    # TLH
                    if { [regexp {^TLH\S*X(\d+)$} $lib_cell_name match drive] != 0 } {
                        # trim ^0
                        regsub {^0+} $drive {} drive
                        if { $drive == "" } { set drive 0 }
                            #if { $period >= $MAXTRAN_LOWDRV_Vall_TMIN0 && $period < $MAXTRAN_LOWDRV_Vall_TMAX0 } ;# remove for analyzing over 480MHz
                            if { $period < $MAXTRAN_LOWDRV_Vall_TMAX0 } {
                                set_maxtran_lowdrv_Vall_F3p200000et08to4p800000et08_TLH $pin $drive $overwrite
                            } elseif { $period >= $MAXTRAN_LOWDRV_Vall_TMIN1 && $period < $MAXTRAN_LOWDRV_Vall_TMAX1 } {
                                set_maxtran_lowdrv_Vall_F1p600000et08to3p200000et08_TLH $pin $drive $overwrite
                            }

                    # THH
                    } elseif { [regexp {^THH\S*X(\d+)$} $lib_cell_name match drive] != 0 } {
                        # trim ^0
                        regsub {^0+} $drive {} drive
                        if { $drive == "" } { set drive 0 }
                            #if { $period >= $MAXTRAN_LOWDRV_Vall_TMIN0 && $period < $MAXTRAN_LOWDRV_Vall_TMAX0 } ;# remove for analyzing over 480MHz
                            if { $period < $MAXTRAN_LOWDRV_Vall_TMAX0 } {
                                set_maxtran_lowdrv_Vall_F3p200000et08to4p800000et08_THH $pin $drive $overwrite
                            } elseif { $period >= $MAXTRAN_LOWDRV_Vall_TMIN1 && $period < $MAXTRAN_LOWDRV_Vall_TMAX1 } {
                                set_maxtran_lowdrv_Vall_F1p600000et08to3p200000et08_THH $pin $drive $overwrite
                            } elseif { $period >= $MAXTRAN_LOWDRV_Vall_TMIN2 } {
                                set_maxtran_lowdrv_Vall_Fto1p600000et08_THH $pin $drive $overwrite
                            }

                    # TMH
                    } elseif { [regexp {^TMH\S*X(\d+)$} $lib_cell_name match drive] != 0 } {
                        # trim ^0
                        regsub {^0+} $drive {} drive
                        if { $drive == "" } { set drive 0 }
                            #if { $period >= $MAXTRAN_LOWDRV_Vall_TMIN0 && $period < $MAXTRAN_LOWDRV_Vall_TMAX0 } ;# remove for analyzing over 480MHz
                            if { $period < $MAXTRAN_LOWDRV_Vall_TMAX0 } {
                                set_maxtran_lowdrv_Vall_F3p200000et08to4p800000et08_TMH $pin $drive $overwrite
                            } elseif { $period >= $MAXTRAN_LOWDRV_Vall_TMIN1 && $period < $MAXTRAN_LOWDRV_Vall_TMAX1 } {
                                set_maxtran_lowdrv_Vall_F1p600000et08to3p200000et08_TMH $pin $drive $overwrite
                            } elseif { $period >= $MAXTRAN_LOWDRV_Vall_TMIN2 } {
                                set_maxtran_lowdrv_Vall_Fto1p600000et08_TMH $pin $drive $overwrite
                            }

                    }
                }
            }
        }

        # set maxtran lowdrv to asynchronous path
        if { [info exists DLCLT_AsyncHalfCyclePath] } {
            foreach keyname [array names DLCLT_AsyncHalfCyclePath] {
                foreach_in_collection tp $DLCLT_AsyncHalfCyclePath($keyname) {
                    # get period
                    set start_time [get_attribute $tp startpoint_clock_open_edge_value]
                    set end_time [get_attribute $tp endpoint_clock_close_edge_value]
                    if { $start_time > $end_time } {
                        set period [expr $start_time - $end_time]
                        set min_clock [get_object_name [get_attribute $tp endpoint_clock]]
                    } else {
                        set period [expr $end_time - $start_time]
                        set min_clock [get_object_name [get_attribute $tp startpoint_clock]]
                    }
                    # set maxtran lowdrv for half cycle path
                    set tp_pins [filter_half_cycle_pin $tp $filter]
                    foreach_in_collection pin [filter_collection $tp_pins "direction=~*out&&is_clock_pin==false&&is_hierarchical==false"] {
                        set lib_cell_name [get_attribute [get_cells -quiet -of $pin] ref_name]
                        # TLH
                        if { [regexp {^TLH\S*X(\d+)$} $lib_cell_name match drive] != 0 } {
                            # trim ^0
                            regsub {^0+} $drive {} drive
                            if { $drive == "" } { set drive 0 }
                                #if { $period >= $MAXTRAN_LOWDRV_Vall_TMIN0 && $period < $MAXTRAN_LOWDRV_Vall_TMAX0 } ;# remove for analyzing over 480MHz
                                if { $period < $MAXTRAN_LOWDRV_Vall_TMAX0 } {
                                    set_maxtran_lowdrv_Vall_F3p200000et08to4p800000et08_TLH $pin $drive $overwrite
                                } elseif { $period >= $MAXTRAN_LOWDRV_Vall_TMIN1 && $period < $MAXTRAN_LOWDRV_Vall_TMAX1 } {
                                    set_maxtran_lowdrv_Vall_F1p600000et08to3p200000et08_TLH $pin $drive $overwrite
                                }

                        # THH
                        } elseif { [regexp {^THH\S*X(\d+)$} $lib_cell_name match drive] != 0 } {
                            # trim ^0
                            regsub {^0+} $drive {} drive
                            if { $drive == "" } { set drive 0 }
                                #if { $period >= $MAXTRAN_LOWDRV_Vall_TMIN0 && $period < $MAXTRAN_LOWDRV_Vall_TMAX0 } ;# remove for analyzing over 480MHz
                                if { $period < $MAXTRAN_LOWDRV_Vall_TMAX0 } {
                                    set_maxtran_lowdrv_Vall_F3p200000et08to4p800000et08_THH $pin $drive $overwrite
                                } elseif { $period >= $MAXTRAN_LOWDRV_Vall_TMIN1 && $period < $MAXTRAN_LOWDRV_Vall_TMAX1 } {
                                    set_maxtran_lowdrv_Vall_F1p600000et08to3p200000et08_THH $pin $drive $overwrite
                                } elseif { $period >= $MAXTRAN_LOWDRV_Vall_TMIN2 } {
                                    set_maxtran_lowdrv_Vall_Fto1p600000et08_THH $pin $drive $overwrite
                                }

                        # TMH
                        } elseif { [regexp {^TMH\S*X(\d+)$} $lib_cell_name match drive] != 0 } {
                            # trim ^0
                            regsub {^0+} $drive {} drive
                            if { $drive == "" } { set drive 0 }
                                #if { $period >= $MAXTRAN_LOWDRV_Vall_TMIN0 && $period < $MAXTRAN_LOWDRV_Vall_TMAX0 } ;# remove for analyzing over 480MHz
                                if { $period < $MAXTRAN_LOWDRV_Vall_TMAX0 } {
                                    set_maxtran_lowdrv_Vall_F3p200000et08to4p800000et08_TMH $pin $drive $overwrite
                                } elseif { $period >= $MAXTRAN_LOWDRV_Vall_TMIN1 && $period < $MAXTRAN_LOWDRV_Vall_TMAX1 } {
                                    set_maxtran_lowdrv_Vall_F1p600000et08to3p200000et08_TMH $pin $drive $overwrite
                                } elseif { $period >= $MAXTRAN_LOWDRV_Vall_TMIN2 } {
                                    set_maxtran_lowdrv_Vall_Fto1p600000et08_TMH $pin $drive $overwrite
                                }

                        }
                    }
                }
            }
        }
    }
}

### unsuppress PTE-079 warning
unsuppress_message PTE-079

### Warning: no lowdrv cell
if { $DLCLT_SET_MAXTRAN_LOWDRV_FLAG == 0 } {
    puts "Warning(DLCLT): No low drive cell found."
}
