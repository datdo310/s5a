#######
# v0r01: 2017/03/08 Y.Oda: 1st for RV28F base on RV40F script
# v0r02: 2017/06/20 Y.Oda: change frequency margin formulra
# v0r03: 2017/06/27 Y.Oda: LVT -> ULVT
# v0r04: 2019/01/10 Change Initial Transition 9999.999->99999.999
#######
############################################################
# Set MaxTransition for low drive cell main script
#     Generated by make_DRV_script V03.01.00
############################################################
############################################################
# set constraint factors
############################################################
# time scale factor
set Tunit [get_attribute [current_design] time_unit_in_second]
set Tfactor [expr 1.0e-9/$Tunit]
# capacitance scale factor
set Cunit [get_attribute [current_design] capacitance_unit_in_farad]
set Cfactor [expr 1.0e-12/$Cunit]

############################################################
# source utility procedures
############################################################
#if { ![info exists DLCLT_UTIL_PATH] } {
#    set DLCLT_UTIL_PATH "/common/appl/Renesas/OPENCAD/R2016.03/tools/DELAYCALC_LITE/utility"
#}
#source ${DLCLT_UTIL_PATH}/get_min_period.tcl
#source ${DLCLT_UTIL_PATH}/get_half_cycle_path_v2.tcl
#
#############################################################
## source constraint setting procedures
#############################################################
## lowdrv constraint setting procedure
#if { ![info exists DLCLT_MAXTRAN_LOWDRV_PROC_TCL] } {
#    source /eda04/daltmu08/rv40f_phase1_drv_env_for_yoshida-san/run.config.file/drv_scr/dlclt_maxtran_lowdrv_proc.scr
#} else {
#    source $DLCLT_MAXTRAN_LOWDRV_PROC_TCL
#}

############################################################
# define global variables
############################################################
global DLCLT_HalfCyclePath
# Period limit for half cycle check
if { [info exists DLCLT_HALF_CYCLE_MAXTRAN_PERIOD_LIMIT] } {
    set DLCLT_HALF_CYCLE_MAXTRAN_PERIOD_LIMIT [expr $DLCLT_HALF_CYCLE_MAXTRAN_PERIOD_LIMIT * $Tfactor]
} else {
    set DLCLT_HALF_CYCLE_MAXTRAN_PERIOD_LIMIT 1.0e9
}

### suppress PTE-079 warning
suppress_message PTE-079

#############################################################
## Main routine
#############################################################
if {[info exist PTECO_FIX_DRC]} {
    puts "* Information : Skip Reset maxtran constraints"
    set overwrite 0
} else {
    puts "* Information : Reset maxtran constraints"
    set_max_transition 99999.999 [get_pins * -hier]
    set_max_transition 99999.999 -data_path [all_clocks]
    set_max_transition 99999.999 -clock_path [all_clocks]
    set overwrite 1
}



### suppress PTE-079 warning
suppress_message PTE-079

### set maxtran lowdrv flag
global DLCLT_SET_MAXTRAN_LOWDRV_FLAG
set DLCLT_SET_MAXTRAN_LOWDRV_FLAG 0

### main routine for normal cycle path
# define overwrite flag 1(true)
# set overwrite 1			;# Comment out for PTECO
set RV28F_MAXTRAN_LOWDRV_Vall_TMIN0 [expr 2.05e-09/$Tunit/(1+$MAXTRANCAP_FREQ_RELAX)]	;# over 400MHz
set RV28F_MAXTRAN_LOWDRV_Vall_TMAX0 [expr 3.20e-09/$Tunit/(1+$MAXTRANCAP_FREQ_RELAX)]	;# Over 300MHz
set RV28F_MAXTRAN_LOWDRV_Vall_TMIN1 [expr 3.20e-09/$Tunit/(1+$MAXTRANCAP_FREQ_RELAX)]	;# Over 300MHz

### main loop for THH
foreach_in_collection inst [get_cells * -hier -quiet -filter "ref_name=~THH*X*&&is_hierarchical==false"] {
    # get library cell name
    set lib_cell_name [get_attribute $inst ref_name]

    # get drive
    if { [regexp {^THH\S*X(\d+)$} $lib_cell_name match drive] == 0 } { continue }
    # trim ^0
    regsub {^0+} $drive {} drive
    if { $drive == "" } { set drive 0 }

    # check drive limit
    if { [RV28F_check_drive_limit_THH $drive] == 0 } { continue }

    # get output pins
    set outpins [get_pins -quiet -leaf -of $inst -filter "direction=~*out&&is_hierarchical==false"]
    if { $outpins == "" } { continue }

    # set maxtran lowdrv cell's pin
    foreach_in_collection pin $outpins {
        # get minimum period
        set path_flag [get_attribute $pin dlclt_clk_path_flag]
        set period [get_min_period $pin "out" $path_flag]
        #if { $period >= $RV28F_MAXTRAN_LOWDRV_Vall_TMIN0 && $period < $RV28F_MAXTRAN_LOWDRV_Vall_TMAX0 } ;# remove for analyzing over 480MHz
        if { $period < $RV28F_MAXTRAN_LOWDRV_Vall_TMAX0 } {
            # y.oda Warning: this will be change new lowdrive constraints 
            RV28F_set_maxtran_lowdrv_Vall_Fto300MHz_THH $pin $drive $overwrite
        } elseif { $period >= $RV28F_MAXTRAN_LOWDRV_Vall_TMIN1 } {
            RV28F_set_maxtran_lowdrv_Vall_Fto300MHz_THH $pin $drive $overwrite
        }

    }
}

### main loop for TSH
foreach_in_collection inst [get_cells * -hier -quiet -filter "ref_name=~TSH*X*&&is_hierarchical==false"] {
    # get library cell name
    set lib_cell_name [get_attribute $inst ref_name]

    # get drive
    if { [regexp {^TSH\S*X(\d+)$} $lib_cell_name match drive] == 0 } { continue }
    # trim ^0
    regsub {^0+} $drive {} drive
    if { $drive == "" } { set drive 0 }

    # check drive limit
    if { [RV28F_check_drive_limit_TSH $drive] == 0 } { continue }

    # get output pins
    set outpins [get_pins -quiet -leaf -of $inst -filter "direction=~*out&&is_hierarchical==false"]
    if { $outpins == "" } { continue }

    # set maxtran lowdrv cell's pin
    foreach_in_collection pin $outpins {
        # get minimum period
        set path_flag [get_attribute $pin dlclt_clk_path_flag]
        set period [get_min_period $pin "out" $path_flag]
        #if { $period >= $RV28F_MAXTRAN_LOWDRV_Vall_TMIN0 && $period < $RV28F_MAXTRAN_LOWDRV_Vall_TMAX0 } ;# remove for analyzing over 480MHz
        if { $period < $RV28F_MAXTRAN_LOWDRV_Vall_TMAX0 } {
            # y.oda Warning: this will be change new lowdrive constraints 
            RV28F_set_maxtran_lowdrv_Vall_Fto300MHz_TSH $pin $drive $overwrite
        } elseif { $period >= $RV28F_MAXTRAN_LOWDRV_Vall_TMIN1 } {
            RV28F_set_maxtran_lowdrv_Vall_Fto300MHz_TSH $pin $drive $overwrite
        }

    }
}

### main loop for TULH
foreach_in_collection inst [get_cells * -hier -quiet -filter "ref_name=~TULH*X*&&is_hierarchical==false"] {
    # get library cell name
    set lib_cell_name [get_attribute $inst ref_name]

    # get drive
    if { [regexp {^TULH\S*X(\d+)$} $lib_cell_name match drive] == 0 } { continue }
    # trim ^0
    regsub {^0+} $drive {} drive
    if { $drive == "" } { set drive 0 }

    # check drive limit
    if { [RV28F_check_drive_limit_TULH $drive] == 0 } { continue }

    # get output pins
    set outpins [get_pins -quiet -leaf -of $inst -filter "direction=~*out&&is_hierarchical==false"]
    if { $outpins == "" } { continue }

    # set maxtran lowdrv cell's pin
    foreach_in_collection pin $outpins {
        # get minimum period
        set path_flag [get_attribute $pin dlclt_clk_path_flag]
        set period [get_min_period $pin "out" $path_flag]
        #if { $period >= $RV28F_MAXTRAN_LOWDRV_Vall_TMIN0 && $period < $RV28F_MAXTRAN_LOWDRV_Vall_TMAX0 } ;# remove for analyzing over 480MHz
        if { $period < $RV28F_MAXTRAN_LOWDRV_Vall_TMAX0 } {
            # y.oda Warning: this will be change new lowdrive constraints 
            RV28F_set_maxtran_lowdrv_Vall_Fto300MHz_TULH $pin $drive $overwrite
        } elseif { $period >= $RV28F_MAXTRAN_LOWDRV_Vall_TMIN1 } {
            RV28F_set_maxtran_lowdrv_Vall_Fto300MHz_TULH $pin $drive $overwrite
        }

    }
}



### main loop for half cycle paths
# set overwrite flag 0(false)
set overwrite 0
if { [info exists DLCLT_ENABLE_HALF_CYCLE_MAXTRAN_LOWDRV] && [string equal -nocase $DLCLT_ENABLE_HALF_CYCLE_MAXTRAN_LOWDRV "yes"] } {
    if { $DLCLT_HALF_CYCLE_MAXTRAN_PIN_LIST != "" } {
        # get half cycle path
        if { ![info exists DLCLT_HalfCyclePath] } {
            set DLCLT_HalfCyclePath [get_half_cycle_path_start_end_pair $DLCLT_HALF_CYCLE_MAXTRAN_PIN_LIST \
                $DLCLT_HALF_CYCLE_MAXTRAN_NWORST $DLCLT_HALF_CYCLE_MAXTRAN_MAX_PATHS]
        }
        set filter ""
        foreach_in_collection tp $DLCLT_HalfCyclePath {
            # set half cycle period
            if { [string equal -nocase $DLCLT_HALF_CYCLE_CLOCK_POINT "start"] } {
                set clkname [get_object_name [get_attribute $tp startpoint_clock]]
            } elseif { [string equal -nocase $DLCLT_HALF_CYCLE_CLOCK_POINT "end"] } {
                set clkname [get_object_name [get_attribute $tp endpoint_clock]]
            } else {
                set clkname [get_object_name [get_attribute $tp startpoint_clock]]
                append clkname " [get_object_name [get_attribute $tp endpoint_clock]]"
            }
            get_min_clock_and_period_from_namelist $clkname min_clock period
            set period [expr $period * 0.5]
            # set maxtran lowdrv for half cycle path
            set tp_pins [filter_half_cycle_pin $tp $filter]
            foreach_in_collection pin [filter_collection $tp_pins "direction=~*out&&is_clock_pin==false&&is_hierarchical==false"] {
                set lib_cell_name [get_attribute [get_cells -quiet -of $pin] ref_name]
                # TULH
                if { [regexp {^TULH\S*X(\d+)$} $lib_cell_name match drive] != 0 } {
                    # trim ^0
                    regsub {^0+} $drive {} drive
                    if { $drive == "" } { set drive 0 }
                        #if { $period >= $RV28F_MAXTRAN_LOWDRV_Vall_TMIN0 && $period < $RV28F_MAXTRAN_LOWDRV_Vall_TMAX0 } ;# remove for analyzing over 480MHz
                        if { $period < $RV28F_MAXTRAN_LOWDRV_Vall_TMAX0 } {
			    # y.oda Warning: this will be change new lowdrive constraints 
			    RV28F_set_maxtran_lowdrv_Vall_Fto300MHz_TULH $pin $drive $overwrite
                        } elseif { $period >= RV28F_$MAXTRAN_LOWDRV_Vall_TMIN1 } {
			    RV28F_set_maxtran_lowdrv_Vall_Fto300MHz_TULH $pin $drive $overwrite
                        }

                # TSH
                } elseif { [regexp {^TSH\S*X(\d+)$} $lib_cell_name match drive] != 0 } {
                    # trim ^0
                    regsub {^0+} $drive {} drive
                    if { $drive == "" } { set drive 0 }
                        #if { $period >= $RV28F_MAXTRAN_LOWDRV_Vall_TMIN0 && $period < $RV28F_MAXTRAN_LOWDRV_Vall_TMAX0 } ;# remove for analyzing over 480MHz
                        if { $period < $RV28F_MAXTRAN_LOWDRV_Vall_TMAX0 } {
			    # y.oda Warning: this will be change new lowdrive constraints 
			    RV28F_set_maxtran_lowdrv_Vall_Fto300MHz_TSH $pin $drive $overwrite
                        } elseif { $period >= RV28F_$MAXTRAN_LOWDRV_Vall_TMIN1 } {
			    RV28F_set_maxtran_lowdrv_Vall_Fto300MHz_TSH $pin $drive $overwrite
                        }

                # THH
                } elseif { [regexp {^THH\S*X(\d+)$} $lib_cell_name match drive] != 0 } {
                    # trim ^0
                    regsub {^0+} $drive {} drive
                    if { $drive == "" } { set drive 0 }
                        #if { $period >= $RV28F_MAXTRAN_LOWDRV_Vall_TMIN0 && $period < $RV28F_MAXTRAN_LOWDRV_Vall_TMAX0 } ;# remove for analyzing over 480MHz
                        if { $period < $RV28F_MAXTRAN_LOWDRV_Vall_TMAX0 } {
			    # y.oda Warning: this will be change new lowdrive constraints 
			    RV28F_set_maxtran_lowdrv_Vall_Fto300MHz_THH $pin $drive $overwrite
                        } elseif { $period >= RV28F_$MAXTRAN_LOWDRV_Vall_TMIN1 } {
			    RV28F_set_maxtran_lowdrv_Vall_Fto300MHz_THH $pin $drive $overwrite
                        }

                }
            }
        }
    } else {
        # make cell filter
        make_half_cycle_check_filter $DLCLT_HALF_CYCLE_MAXTRAN_INCLUDE_LIST \
                $DLCLT_HALF_CYCLE_MAXTRAN_EXCLUDE_LIST filter
        # get half cycle path
        if { ![info exists DLCLT_HalfCyclePath] } {
            # clock loop
            foreach_in_collection clock [get_clocks *] {
                set clkname [get_object_name $clock]
                # get half cycle path
                get_half_cycle_path_for_clock $clock $filter \
                        $DLCLT_HALF_CYCLE_MAXTRAN_NWORST $DLCLT_HALF_CYCLE_MAXTRAN_MAX_PATHS
            }
        }
        # set lowdrv
        foreach keyname [array names DLCLT_HalfCyclePath] {
            foreach_in_collection tp $DLCLT_HalfCyclePath($keyname) {
                # set half cycle period
                if { [string equal -nocase $DLCLT_HALF_CYCLE_CLOCK_POINT "start"] } {
                    set pckname [get_object_name [get_attribute $tp startpoint_clock]]
                } elseif { [string equal -nocase $DLCLT_HALF_CYCLE_CLOCK_POINT "end"] } {
                    set pckname [get_object_name [get_attribute $tp endpoint_clock]]
                } else {
                    set pckname [get_object_name [get_attribute $tp startpoint_clock]]
                    lappend pckname [get_object_name [get_attribute $tp endpoint_clock]]
                }
                get_min_clock_and_period_from_namelist $pckname min_clock period
                set period [expr $period * 0.5]
                # set maxtran lowdrv for half cycle path
                set tp_pins [filter_half_cycle_pin $tp $filter]
                foreach_in_collection pin [filter_collection $tp_pins "direction=~*out&&is_clock_pin==false&&is_hierarchical==false"] {
                    set lib_cell_name [get_attribute [get_cells -quiet -of $pin] ref_name]
                    # TULH
                    if { [regexp {^TULH\S*X(\d+)$} $lib_cell_name match drive] != 0 } {
                        # trim ^0
                        regsub {^0+} $drive {} drive
                        if { $drive == "" } { set drive 0 }
                            #if { $period >= $RV28F_MAXTRAN_LOWDRV_Vall_TMIN0 && $period < $RV28F_MAXTRAN_LOWDRV_Vall_TMAX0 } ;# remove for analyzing over 480MHz
                            if { $period < $RV28F_MAXTRAN_LOWDRV_Vall_TMAX0 } {
				# y.oda Warning: this will be change new lowdrive constraints 
				RV28F_set_maxtran_lowdrv_Vall_Fto300MHz_TULH $pin $drive $overwrite
                            } elseif { $period >= $RV28F_MAXTRAN_LOWDRV_Vall_TMIN1 } {
				RV28F_set_maxtran_lowdrv_Vall_Fto300MHz_TULH $pin $drive $overwrite
                            }

                    # TSH
                    } elseif { [regexp {^TSH\S*X(\d+)$} $lib_cell_name match drive] != 0 } {
                        # trim ^0
                        regsub {^0+} $drive {} drive
                        if { $drive == "" } { set drive 0 }
                            #if { $period >= $RV28F_MAXTRAN_LOWDRV_Vall_TMIN0 && $period < $RV28F_MAXTRAN_LOWDRV_Vall_TMAX0 } ;# remove for analyzing over 480MHz
                            if { $period < $RV28F_MAXTRAN_LOWDRV_Vall_TMAX0 } {
				# y.oda Warning: this will be change new lowdrive constraints 
				RV28F_set_maxtran_lowdrv_Vall_Fto300MHz_TSH $pin $drive $overwrite
                            } elseif { $period >= $RV28F_MAXTRAN_LOWDRV_Vall_TMIN1 } {
				RV28F_set_maxtran_lowdrv_Vall_Fto300MHz_TSH $pin $drive $overwrite
                            }

                    # THH
                    } elseif { [regexp {^THH\S*X(\d+)$} $lib_cell_name match drive] != 0 } {
                        # trim ^0
                        regsub {^0+} $drive {} drive
                        if { $drive == "" } { set drive 0 }
                            #if { $period >= $RV28F_MAXTRAN_LOWDRV_Vall_TMIN0 && $period < $RV28F_MAXTRAN_LOWDRV_Vall_TMAX0 } ;# remove for analyzing over 480MHz
                            if { $period < $RV28F_MAXTRAN_LOWDRV_Vall_TMAX0 } {
				# y.oda Warning: this will be change new lowdrive constraints 
				RV28F_set_maxtran_lowdrv_Vall_Fto300MHz_THH $pin $drive $overwrite
                            } elseif { $period >= $RV28F_MAXTRAN_LOWDRV_Vall_TMIN1 } {
				RV28F_set_maxtran_lowdrv_Vall_Fto300MHz_THH $pin $drive $overwrite
                            }

                    }
                }
            }
        }

        # set maxtran lowdrv to asynchronous path
        if { [info exists DLCLT_AsyncHalfCyclePath] } {
            foreach keyname [array names DLCLT_AsyncHalfCyclePath] {
                foreach_in_collection tp $DLCLT_AsyncHalfCyclePath($keyname) {
                    # get period
                    set start_time [get_attribute $tp startpoint_clock_open_edge_value]
                    set end_time [get_attribute $tp endpoint_clock_close_edge_value]
                    if { $start_time > $end_time } {
                        set period [expr $start_time - $end_time]
                        set min_clock [get_object_name [get_attribute $tp endpoint_clock]]
                    } else {
                        set period [expr $end_time - $start_time]
                        set min_clock [get_object_name [get_attribute $tp startpoint_clock]]
                    }
                    # set maxtran lowdrv for half cycle path
                    set tp_pins [filter_half_cycle_pin $tp $filter]
                    foreach_in_collection pin [filter_collection $tp_pins "direction=~*out&&is_clock_pin==false&&is_hierarchical==false"] {
                        set lib_cell_name [get_attribute [get_cells -quiet -of $pin] ref_name]
                        # TULH
                        if { [regexp {^TULH\S*X(\d+)$} $lib_cell_name match drive] != 0 } {
                            # trim ^0
                            regsub {^0+} $drive {} drive
                            if { $drive == "" } { set drive 0 }
                                #if { $period >= $RV28F_MAXTRAN_LOWDRV_Vall_TMIN0 && $period < $RV28F_MAXTRAN_LOWDRV_Vall_TMAX0 } ;# remove for analyzing over 480MHz
                                if { $period < $RV28F_MAXTRAN_LOWDRV_Vall_TMAX0 } {
				    # y.oda Warning: this will be change new lowdrive constraints 
				    RV28F_set_maxtran_lowdrv_Vall_Fto300MHz_TULH $pin $drive $overwrite
                                } elseif { $period >= $RV28F_MAXTRAN_LOWDRV_Vall_TMIN1 } {
				    RV28F_set_maxtran_lowdrv_Vall_Fto300MHz_TULH $pin $drive $overwrite
                                }

                        # TSH
                        } elseif { [regexp {^TSH\S*X(\d+)$} $lib_cell_name match drive] != 0 } {
                            # trim ^0
                            regsub {^0+} $drive {} drive
                            if { $drive == "" } { set drive 0 }
                                #if { $period >= $RV28F_MAXTRAN_LOWDRV_Vall_TMIN0 && $period < $RV28F_MAXTRAN_LOWDRV_Vall_TMAX0 } ;# remove for analyzing over 480MHz
                                if { $period < $RV28F_MAXTRAN_LOWDRV_Vall_TMAX0 } {
				    # y.oda Warning: this will be change new lowdrive constraints 
				    RV28F_set_maxtran_lowdrv_Vall_Fto300MHz_TSH $pin $drive $overwrite
                                } elseif { $period >= $RV28F_MAXTRAN_LOWDRV_Vall_TMIN1 } {
				    RV28F_set_maxtran_lowdrv_Vall_Fto300MHz_TSH $pin $drive $overwrite
                                }
                        # THH
                        } elseif { [regexp {^THH\S*X(\d+)$} $lib_cell_name match drive] != 0 } {
                            # trim ^0
                            regsub {^0+} $drive {} drive
                            if { $drive == "" } { set drive 0 }
                                #if { $period >= $RV28F_MAXTRAN_LOWDRV_Vall_TMIN0 && $period < $RV28F_MAXTRAN_LOWDRV_Vall_TMAX0 } ;# remove for analyzing over 480MHz
                                if { $period < $RV28F_MAXTRAN_LOWDRV_Vall_TMAX0 } {
				    # y.oda Warning: this will be change new lowdrive constraints 
				    RV28F_set_maxtran_lowdrv_Vall_Fto300MHz_THH $pin $drive $overwrite
                                } elseif { $period >= $RV28F_MAXTRAN_LOWDRV_Vall_TMIN1 } {
				    RV28F_set_maxtran_lowdrv_Vall_Fto300MHz_THH $pin $drive $overwrite
                                }

                        }
                    }
                }
            }
        }
    }
}

### unsuppress PTE-079 warning
unsuppress_message PTE-079

### Warning: no lowdrv cell
if { $DLCLT_SET_MAXTRAN_LOWDRV_FLAG == 0 } {
    puts "Warning(DLCLT): No low drive cell found."
}
